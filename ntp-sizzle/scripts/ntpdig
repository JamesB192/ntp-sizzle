#! /usr/bin/env python
# -*- coding: utf-8 -*-
"""
ntpdig - simple SNTP client

"""

# Copyright the NTPsec project contributors
#
# SPDX-License-Identifier: BSD-2-Clause
# This code runs identically under Python 2 and Python 3. Keep it that way!

from __future__ import print_function, division
import getopt
import math
import select
import socket
import sys
import time

try:
    import ntp.magic
    import ntp.packet
    import ntp.util
except ImportError as e:
    sys.stderr.write(
        "ntpdig: can't find Python NTP library -- check PYTHONPATH.\n"
    )
    sys.stderr.write("%s\n" % e)
    sys.exit(1)
# This code is somewhat stripped down from the legacy C version.  It
# does however have one additional major feature; it can filter
# out falsetickers from multiple samples, like the ntpdate of old,
# rather than just taking the first reply it gets.
#
# Listening to broadcast addresses is not implemented because that is
# impossible to secure. KOD recording is also not implemented, as it
# can too easily be spammed.  Thus, the options -b and -K are not
# implemented.
#
# There are no version 3 NTP servers left, so the -o version for setting
# NTP version has been omitted.
#
# Because ntpdig doesn't use symmetric-peer mode (it never did, and NTPsec has
# abolished that mode because it was a security hazard), there's no need to
# set the packet source port, so -r/--usereservedport has been dropped.
# If this option ever needs to be reinstated, the magic is described here:
# http://stackoverflow.com/questions/2694212/socket-set-source-port-number
# and would be s.bind(('', 123)) right after the socket creation.
#
# The -w/--wait and -W/--nowait options only made sense with asynchronous
# DNS.  Asynchronous DNS was absurd overkill for this application, we are
# not looking up 20,000 hosts here.  It has not been implemented, so neither
# have these options.
#
# Finally, logging to syslog by default was a design error, violating
# Unix principles, that has been fixed. To get this behavior when
# running in a script, redirect standard error to logger(1).
#
# The one new option in this version is -p, borrowed from ntpdate.
NTP_INFIN = 15  # max stratum, infinity a la Bellman-Ford


def read_append(read_socket, packets, saved_packet):
    """Read the sockaet, appendin the derived packet list."""
    data, _ = read_socket.recvfrom(1024)
    in_packet = ntp.packet.SyncPacket(data)
    resolved = saved_packet.resolved[0]
    if VERBOSITY >= 2:
        ntp.packet.dump_hex_printable(data)
    if CREDENTIALS:
        if not ntp.packet.Authenticator.have_mac(data):
            if VERBOSITY:
                log("no MAC on reply from %s" % saved_packet.hostname)
        if not CREDENTIALS.verify_mac(
            data, packet_end=48, mac_begin=48
        ):
            in_packet.trusted = False
            log("MAC verification on reply from %s failed" % resolved)
        elif VERBOSITY:
            log(
                "MAC verification on reply from %s succeeded" % resolved
            )
    in_packet.hostname = saved_packet.hostname
    in_packet.resolved = resolved
    packets.append(in_packet)
    return packets


def queryhost(server, concurrent, timeout=5, port=123, bindaddr=None):
    "Query IP addresses associated with a specified host."
    try:
        iptuples = socket.getaddrinfo(
            server,
            port,
            ADDRESS_FAMILY,
            socket.SOCK_DGRAM,
            socket.IPPROTO_UDP,
        )
    except socket.gaierror as error:
        log(
            "lookup of %s failed, errno %d = %s"
            % (server, error.args[0], error.args[1])
        )
        return []
    bindsock = None
    if bindaddr:
        try:
            bindsock = socket.getaddrinfo(
                bindaddr,
                None,
                ADDRESS_FAMILY,
                socket.SOCK_DGRAM,
                socket.IPPROTO_UDP,
            )
        except socket.gaierror as error:
            log(
                "lookup of %s failed, errno %d = %s"
                % (server, error.args[0], error.args[1])
            )
            raise SystemExit(1)
    sockets = []
    packets = []
    request = ntp.packet.SyncPacket()
    request.hostname = server
    need_gap = (len(iptuples) > 1) and (GAP > 0)
    firstloop = True
    for (
        family,
        socktype,
        _,
        _,
        sockaddr,
    ) in iptuples:  # proto, canon_name
        request.transmit_timestamp = ntp.packet.SyncPacket.posix_to_ntp(
            time.time()
        )
        request.resolved = sockaddr
        out_packet = request.flatten()  # belt
        if need_gap and not firstloop:
            time.sleep(GAP)
        if firstloop:
            firstloop = False
        if VERBOSITY:
            log("querying %s (%s)" % (sockaddr[0], server))
        try:
            write_socket = socket.socket(family, socktype)
        except OSError:
            if VERBOSITY:
                log(
                    "Skipping because socket for %s of family"
                    " %d, type %d could not be formed."
                    % (sockaddr[0], family, socktype)
                )
            continue
        if bindsock:
            try:
                if VERBOSITY:
                    log("Binding to Source IP %s," % bindaddr)
                write_socket.bind(bindsock[0][4])
            except OSError as error:
                log(
                    "binding to %s failed, errno %d = %s"
                    % (bindaddr, error.args[0], error.args[1])
                )
                raise SystemExit(1)
        if KEY_ID and KEY_TYPE and PASSWORD:
            if VERBOSITY:
                log(
                    "authenticating with %s key %d" % (KEY_TYPE, KEY_ID)
                )
            mac = ntp.packet.Authenticator.compute_mac(
                out_packet, KEY_ID, KEY_TYPE, PASSWORD
            )
            if mac is None:
                log("MAC generation failed while querying %s" % server)
                raise SystemExit(1)
            if 68 <= len(out_packet):  # suspenders
                out_packet += mac
        try:
            write_socket.sendto(out_packet, sockaddr)
        except socket.error as error:
            if VERBOSITY:
                log("socket error on transmission: %s" % error)
            continue
        if VERBOSITY >= 2:
            log("Sent to %s:" % (sockaddr[0],))
            ntp.packet.dump_hex_printable(out_packet)
        if concurrent:
            sockets.append(write_socket)
        else:
            read_socket, _, _ = select.select(
                [write_socket], [], [], timeout
            )
            if read_socket:
                read_append(write_socket, packets, request)
        while sockets:
            read_socket, _, _ = select.select(sockets, [], [], timeout)
            if not read_socket:
                return packets
            for write_socket in sockets:
                read_append(write_socket, packets, request)
                sockets.remove(write_socket)
    return packets


def clock_select(packets):
    "Select the pick-of-the-litter clock from the samples we've got."
    # This is a slightly simplified version of the filter ntpdate used

    # This first chunk of code is supposed to go through all
    # servers we know about to find the servers that
    # are most likely to succeed. We run through the list
    # doing the sanity checks and trying to insert anyone who
    # looks okay. We are at all times aware that we should
    # only keep samples from the top two strata.
    #
    filtered = []
    for response in packets:

        def drop(msg):
            log("%s: Response dropped: %s" % (response.hostname, msg))

        if response.stratum > NTP_INFIN:
            drop("stratum too high")
            continue
        if response.version() < ntp.magic.NTP_OLDVERSION:
            drop("response version %d is too old" % response.version())
            continue
        if response.mode() != ntp.magic.MODE_SERVER:
            drop("unexpected response mode %d" % response.mode())
            continue
        if response.version() > ntp.magic.NTP_VERSION:
            drop("response version %d is too new" % response.version())
            continue
        if response.stratum == 0:
            # FIXME: Do some kind of semi-useful diagnostic dump here
            drop("stratum 0, probable KOD packet")
            continue
        if response.leap() == "unsync":
            drop("leap not in sync")
            continue
        if not response.trusted:
            drop("request was authenticated but server is untrusted")
            continue
        # Bypass this test if we ever support broadcast-client mode again
        if response.origin_timestamp == 0:
            drop("unexpected response timestamp")
            continue
        filtered.append(response)

    if len(filtered) <= 1:
        return filtered

    # Sort by stratum and other figures of merit
    filtered.sort(key=lambda s: (s.stratum, s.synchd(), s.root_delay))

    # Return the best
    return filtered[:1]


def report(packet, json):
    "Report on the SNTP packet selected for display, and its adjustment."
    say = sys.stdout.write

    packet.posixize()

    # The server's idea of the time
    local_time_parts = time.localtime(int(packet.transmit_timestamp))
    microsconds = int(packet.transmit_timestamp * 1000000) % 1000000

    if local_time_parts.tm_isdst:
        tmoffset = -time.altzone // 60  # In minutes
    else:
        tmoffset = -time.timezone // 60  # In minutes

    # Number of decimal digits of precision indicated by the precision field
    digits = min(6, -int(math.log10(2**packet.precision)))

    date = time.strftime("%Y-%m-%d", local_time_parts)
    tod = (
        time.strftime("%T", local_time_parts)
        + (".%0*d" % (digits, microsconds)).rstrip()
    )
    sgn = ("%+d" % tmoffset)[0]
    time_zone = "%s%02d%02d" % (sgn, abs(tmoffset) // 60, tmoffset % 60)

    if json:
        say(
            '{"time":"%sT%s%s","offset":%f,"precision":%f,"host":"%s",'
            '"ip":"%s","stratum":%s,"leap":"%s","adjusted":%s,"delay":%f}\n'
            % (
                date,
                tod,
                time_zone,
                packet.adjust(),
                packet.synchd(),
                packet.hostname,
                packet.resolved or packet.hostname,
                packet.stratum,
                packet.leap(),
                "true" if adjusted else "false",
                packet.delta(),
            )
        )
    else:
        say(
            "%s %s (%s) %+f +/- %f %s"
            % (
                date,
                tod,
                time_zone,
                packet.adjust(),
                packet.synchd(),
                packet.hostname,
            )
        )
        if packet.resolved and packet.resolved != packet.hostname:
            say(" " + packet.resolved)
        say(" s%d %s\n" % (packet.stratum, packet.leap()))


USAGE = """
USAGE:  ntpdig [-<flag> [<val>] | --<name>[{=| }<val>]]...
                [ hostname-or-IP ...]
  Flg Arg Option-Name     Description
   -4 no  ipv4           Force IPv4 DNS name resolution
                                - prohibits the option 'ipv6'
   -6 no  ipv6           Force IPv6 DNS name resolution
                                - prohibits the option 'ipv4'
   -a Num authentication  Enable authentication with the numbered key
   -c yes concurrent      Hosts to be queried concurrently
   -d no  debug           Increase debug verbosity
   -D yes set-debug-level Set debug verbosity
   -g yes gap             Set gap between requests in milliseconds
   -I IP  bindaddr        Set the source address to send request on
   -j no  json            Use JSON output format
   -l Str logfile         Log to specified logfile
                                 - prohibits the option 'syslog'
   -p yes samples         Number of samples to take (default 1)
   -S no  step            Set (step) the time with clock_settime()
                                 - prohibits the option 'step'
   -s no  slew            Set (slew) the time with adjtime()
                                 - prohibits the option 'slew'
   -t Num timeout         Request timeout in seconds (default 5)
   -k Str keyfile         Specify a keyfile. ntpdig will look in this file
                          for the key specified with -a
   -V no version          Output version information and exit
   -h no  help            Display extended usage information and exit
"""


if __name__ == "__main__":
    BIN_VER = "2024.04.24"
    ntp.util.stdversioncheck(BIN_VER)
    try:
        try:
            (options, arguments) = getopt.getopt(
                sys.argv[1:],
                "46a:c:dD:g:hI:jk:l:M:o:p:r:Sst:wWV",
                [
                    "ipv4",
                    "ipv6",
                    "bindaddr=",
                    "authentication=",
                    "concurrent=",
                    "gap=",
                    "help",
                    "json",
                    "keyfile=",
                    "logfile=",
                    "replay=",
                    "samples=",
                    "steplimit=",
                    "step",
                    "slew",
                    "timeout=",
                    "debug",
                    "set-debug-level=",
                    "version",
                ],
            )
        except getopt.GetoptError as e:
            print(e)
            raise SystemExit(1)
        progname = sys.argv[0]

        logfp = sys.stderr
        log = lambda m: logfp.write("ntpdig: %s\n" % m)

        ADDRESS_FAMILY = socket.AF_UNSPEC
        BIND_ADDRESS = None
        AUTH_KEY = None
        concurrent_hosts = []
        VERBOSITY = 0
        GAP = 0.05
        JSON = False
        KEY_FILE = None
        STEP_LIMIT = 0  # Default is intentionally zero
        SAMPLES = 1
        STEP_TIME = False
        SLEW_TIME = False
        TIMEOUT = 5
        REAPLAY = None
        try:
            for switch, val in options:
                if switch in ("-4", "--ipv4"):
                    ADDRESS_FAMILY = socket.AF_INET
                elif switch in ("-6", "--ipv6"):
                    ADDRESS_FAMILY = socket.AF_INET6
                elif switch in ("-a", "--authentication"):
                    ERROR_MESSAGE = (
                        "Error: -a parameter '%s' not a number\n"
                    )
                    AUTH_KEY = ntp.util.safeargcast(
                        val, int, ERROR_MESSAGE, USAGE
                    )
                elif switch in ("-c", "--concurrent"):
                    concurrent_hosts.append(val)
                elif switch in ("-d", "--debug"):
                    VERBOSITY += 1
                elif switch in ("-D", "--set-debug-level"):
                    ERROR_MESSAGE = (
                        "Error: -D parameter '%s' not a number\n"
                    )
                    VERBOSITY = ntp.util.safeargcast(
                        val, int, ERROR_MESSAGE, USAGE
                    )
                elif switch in ("-g", "--gap"):
                    ERROR_MESSAGE = (
                        "Error: -g parameter '%s' not a number\n"
                    )
                    GAP = ntp.util.safeargcast(
                        val, int, ERROR_MESSAGE, USAGE
                    )
                elif switch in ("-I", "--bindaddr"):
                    BIND_ADDRESS = val
                elif switch in ("-j", "--json"):
                    JSON = True
                elif switch in ("-k", "--keyfile"):
                    KEY_FILE = val
                elif switch in ("-l", "--logfile"):
                    try:
                        logfp = open(val, "w")
                    except OSError:
                        sys.stderr.write(
                            "logfile open of %s failed.\n" % val
                        )
                        raise SystemExit(1)
                elif switch in ("-M", "--steplimit"):
                    ERROR_MESSAGE = (
                        "Error: -M parameter '%s' not a number\n"
                    )
                    STEP_LIMIT = ntp.util.safeargcast(
                        val, int, ERROR_MESSAGE, USAGE
                    )
                    STEP_LIMIT /= 1000.0
                elif switch in ("-p", "--samples"):
                    ERROR_MESSAGE = (
                        "Error: -p parameter '%s' not a number\n"
                    )
                    SAMPLES = ntp.util.safeargcast(
                        val, int, ERROR_MESSAGE, USAGE
                    )
                    SAMPLES = max(SAMPLES, 1)
                elif switch in ("-r", "--replay"):
                    REAPLAY = val
                elif switch in ("-S", "--step"):
                    STEP_TIME = True
                elif switch in ("-s", "--slew"):
                    SLEW_TIME = True
                elif switch in ("-t", "--timeout"):
                    ERROR_MESSAGE = (
                        "Error: -t parameter '%s' not a number\n"
                    )
                    TIMEOUT = ntp.util.safeargcast(
                        val, int, ERROR_MESSAGE, USAGE
                    )
                elif switch in ("-h", "--help"):
                    print(USAGE)
                    raise SystemExit(0)
                elif switch in ("-V", "--version"):
                    print("ntpdig %s" % BIN_VER)
                    raise SystemExit(0)
                else:
                    sys.stderr.write(
                        "Unknown command line switch or missing argument.\n"
                    )
                    sys.stderr.write(USAGE)
                    raise SystemExit(1)
        except ValueError:
            sys.stderr.write("Invalid argument.\n")
            sys.stderr.write(USAGE)
            raise SystemExit(1)

        GAP /= 1000  # convert to milliseconds

        CREDENTIALS = KEY_ID = KEY_TYPE = PASSWORD = None
        try:
            CREDENTIALS = ntp.packet.Authenticator(KEY_FILE)
        except (OSError, IOError):
            sys.stderr.write(
                "ntpdig: %s nonexistent or unreadable\n" % KEY_FILE
            )
            raise SystemExit(1)
        if CREDENTIALS:
            try:
                (KEY_ID, KEY_TYPE, PASSWORD) = CREDENTIALS.control(
                    AUTH_KEY
                )
            except ValueError:
                # There are no trusted keys.  Barf.
                log("cannot get authentication key")
                raise SystemExit(1)

        if not CREDENTIALS and AUTH_KEY and KEY_FILE is None:
            sys.stderr.write("-a option requires -k.\n")
            raise SystemExit(1)

        if not arguments:
            arguments = ["localhost"]

        if REAPLAY:
            (pkt, dst) = REAPLAY.split(":")
            packet = ntp.packet.SyncPacket(pkt.decode("hex"))
            packet.received = ntp.packet.SyncPacket.posix_to_ntp(
                float(dst)
            )
            returned = [packet]
        else:
            returned = []
            needgap = (SAMPLES > 1) and (GAP > 0)
            FIRST_LOOP = True
            for s in range(SAMPLES):
                if needgap and not FIRST_LOOP:
                    time.sleep(GAP)
                if FIRST_LOOP:
                    FIRST_LOOP = False
                for server in concurrent_hosts:
                    try:
                        returned += queryhost(
                            server=server,
                            concurrent=True,
                            timeout=TIMEOUT,
                            bindaddr=BIND_ADDRESS,
                        )
                    except ntp.packet.SyncException as e:
                        log(str(e))
                        continue
                for server in arguments:
                    try:
                        returned += queryhost(
                            server=server,
                            concurrent=False,
                            timeout=TIMEOUT,
                            bindaddr=BIND_ADDRESS,
                        )
                    except ntp.packet.SyncException as e:
                        log(str(e))
                        continue

            returned = clock_select(returned)

        if returned:
            pkt = returned[0]
            if VERBOSITY:
                # print(repr(pkt))
                def hexstamp(l_fp):
                    return "%08x.%08x" % (
                        l_fp >> 32,
                        l_fp & 0x00000000FFFFFFFF,
                    )

                print(
                    "org t1: %s rec t2: %s"
                    % (hexstamp(pkt.t1()), hexstamp(pkt.t2()))
                )
                print(
                    "xmt t3: %s dst t4: %s"
                    % (hexstamp(pkt.t3()), hexstamp(pkt.t4()))
                )
            pkt.posixize()
            if VERBOSITY:
                print("org t1: %f rec t2: %f" % (pkt.t1(), pkt.t2()))
                print("xmt t3: %f dst t4: %f" % (pkt.t3(), pkt.t4()))
                print(
                    "rec-org t21: %f  xmt-dst t34: %f"
                    % (pkt.t2() - pkt.t1(), pkt.t3() - pkt.t4())
                )
            offset = pkt.adjust()
            adjusted = STEP_TIME and (
                not SLEW_TIME
                or (SLEW_TIME and (abs(offset) > STEP_LIMIT))
            )
            report(pkt, JSON)
            # If we can step but we cannot slew, then step.
            # If we can step or slew and |offset| > steplimit, then step.
            SUCCESS = True
            ntp.ntpc.setprogname("ntpdig")
            if adjusted:
                SUCCESS = ntp.ntpc.step_systime(offset)
            elif SLEW_TIME:
                SUCCESS = ntp.ntpc.adj_systime(offset)
            if SUCCESS:
                raise SystemExit(0)
            raise SystemExit(1)
        log("no eligible servers")
        raise SystemExit(1)
    except KeyboardInterrupt:
        print("")

# end
